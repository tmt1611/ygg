import { useCallback } from 'react';
import * as geminiService from '../services/geminiService.js';
import { getLockedNodeIds, countNodesInTree, compareAndAnnotateTree, findNodeById, updateNodeInTree, initializeNodes, cleanTreeForExport, cleanTreeForState } from '../utils.js';

export const useTreeOperationsAI = ({
  apiKeyIsSet,
  modalManager,
  historyManager,
  projectManager,
  viewStates,
  setError,
  techTreeData,
  setTechTreeData,
  contextText,
  initialPrompt,
  previousTreeStateForUndoProp, 
  setPreviousTreeStateForUndo,
  baseForModalDiffProp, 
  setBaseForModalDiff,
  setIsLoading,
  setIsModifying,
  setModificationPrompt,
  selectedGraphNodeId,
}) => {
  const { openAiSuggestionModal, closeAiSuggestionModal, openConfirmModal, setPendingAiSuggestion, pendingAiSuggestion } = modalManager;
  const { addHistoryEntry } = historyManager;

  const handleGenerateNewTree = useCallback(async () => {
    if (!projectManager || !viewStates) {
      setError("Project or view systems not fully initialized.");
      return;
    }
    const { activeProjectId, saveNewProject, handleSaveActiveProject } = projectManager;
    const { commonViewResetLogic, handleSwitchToFocusView } = viewStates;

    if (!initialPrompt.trim() || !apiKeyIsSet) {
      setError(!apiKeyIsSet ? "API Key not set. Cannot generate." : "Initial prompt (project context) cannot be empty.");
      return;
    }
    const performGeneration = async () => {
      commonViewResetLogic(true); 
      setIsLoading(true); setError(null);
      setPendingAiSuggestion(null); 
      setBaseForModalDiff(null);
      setPreviousTreeStateForUndo(null);
      try {
        const newTree = await geminiService.generateTechTree(initialPrompt);
        setTechTreeData(newTree);

        if (!activeProjectId) {
          const newProject = saveNewProject(newTree, initialPrompt);
          if (!newProject) { throw new Error("Failed to save new project after AI generation."); }
          addHistoryEntry('TREE_INIT_AI', `New project "${initialPrompt}" and tree generated by AI.`, { prompt: initialPrompt });
        } else {
          handleSaveActiveProject(false);
          addHistoryEntry('TREE_INIT_AI', `Tree regenerated for project "${contextText}" by AI.`, { prompt: initialPrompt });
        }
        // Switch to graph view to show the new structure
        if (viewStates) {
            viewStates.setYggdrasilViewMode('graph');
        }
      } catch (e) { setError(e); console.error("Gemini API Error (Generate):", e); } 
      finally { setIsLoading(false); }
    };

    if (techTreeData && (countNodesInTree(techTreeData) > 1 || (techTreeData.name !== 'New Project Root' && techTreeData.children && techTreeData.children.length > 0)) && projectManager.activeProjectId) {
      openConfirmModal({
        title: "Overwrite Current Tree?", message: `Generating a new tree for "${initialPrompt}" will replace the current structure in project "${contextText}". Are you sure?`,
        confirmText: "Overwrite", cancelText: "Cancel", onConfirm: performGeneration,
        confirmButtonStyle: 'danger'
      });
    } else { performGeneration(); }
  }, [
    initialPrompt, apiKeyIsSet, techTreeData, contextText, projectManager, viewStates, 
    setIsLoading, setError, setTechTreeData, setPreviousTreeStateForUndo, setBaseForModalDiff, setPendingAiSuggestion,
    openConfirmModal, addHistoryEntry
  ]);

  const handleApplyAiModification = useCallback(async (modificationPromptValue, useModal = false) => {
    if (!projectManager) {
        setError("Project system not fully initialized for AI modification.");
        return;
    }
    const { activeProjectId, handleSaveActiveProject } = projectManager;

    if (!techTreeData) { 
        setError("No tree data loaded to modify.");
        return;
    }
    if (!modificationPromptValue.trim() || !apiKeyIsSet) {
      setError(!apiKeyIsSet ? "API Key not set. Cannot modify." : "Modification prompt cannot be empty.");
      return;
    }

    setIsModifying(true); setError(null);

    const finalModificationPrompt = modificationPromptValue;
    
    // For both modal and direct apply, the "undo" state is the tree *before* this operation.
    setPreviousTreeStateForUndo(techTreeData); 
    
    try {
      const lockedIds = getLockedNodeIds(techTreeData);
      const suggestedTree = await geminiService.modifyTechTreeByGemini(techTreeData, finalModificationPrompt, lockedIds);
      
      if (useModal) {
        setBaseForModalDiff(techTreeData);
        setPendingAiSuggestion(suggestedTree); 
        openAiSuggestionModal(suggestedTree); 
        addHistoryEntry('TREE_MOD_AI', 'AI proposed modifications (with modal).', { prompt: finalModificationPrompt, projectId: activeProjectId });
      } else {
        // Direct Apply
        const annotatedTree = compareAndAnnotateTree(techTreeData, suggestedTree);
        const cleanTree = cleanTreeForState(annotatedTree.annotatedTree);
        setTechTreeData(cleanTree);
        handleSaveActiveProject(false);
        addHistoryEntry('AI_MOD_CONFIRMED', 'AI modifications directly applied.', { prompt: finalModificationPrompt, projectId: activeProjectId });
        setModificationPrompt('');
      }
    } catch (e) { 
      setError(e); 
      console.error("Gemini API Error (Modify):", e); 
      // If it fails, revert the undo state since nothing happened.
      setPreviousTreeStateForUndo(null);
    }
    finally { setIsModifying(false); }
  }, [
    techTreeData, apiKeyIsSet, projectManager,
    openAiSuggestionModal, setPendingAiSuggestion, addHistoryEntry, 
    setError, setPreviousTreeStateForUndo, setIsModifying, setBaseForModalDiff,
    setTechTreeData, setModificationPrompt
  ]);

  const handleConfirmAiSuggestion = useCallback(() => {
    if (!projectManager) {
        setError("Project system not fully initialized to confirm AI suggestion.");
        return;
    }
    const { activeProjectId, handleSaveActiveProject } = projectManager;
    const suggestionToApply = pendingAiSuggestion; 
    if (suggestionToApply) {
      // The undo state was already set when the suggestion was generated.
      // We annotate to get a consistent structure, then clean it for the main state.
      const annotatedTree = compareAndAnnotateTree(baseForModalDiffProp, suggestionToApply);
      const cleanTree = cleanTreeForState(annotatedTree.annotatedTree);
      setTechTreeData(cleanTree);
      addHistoryEntry('AI_MOD_CONFIRMED', 'AI modifications applied to project from modal.', { nodeCount: countNodesInTree(suggestionToApply), projectId: activeProjectId });
      setModificationPrompt(''); 
      handleSaveActiveProject(false);
      if (viewStates && viewStates.setSelectedGraphNodeId) {
        viewStates.setSelectedGraphNodeId(null);
      }
    }
    setPendingAiSuggestion(null); 
    setBaseForModalDiff(null);    
    // Do NOT clear the undo state, so the user can revert this confirmed change.
    closeAiSuggestionModal();
  }, [
    pendingAiSuggestion, projectManager, baseForModalDiffProp,
    closeAiSuggestionModal, addHistoryEntry, 
    setTechTreeData, setModificationPrompt, setError,
    setPendingAiSuggestion, setBaseForModalDiff,
    viewStates
  ]);

  const handleRejectAiSuggestion = useCallback(() => {
    if (!projectManager) {
        closeAiSuggestionModal();
        return;
    }
    const { activeProjectId } = projectManager;
    addHistoryEntry('AI_MOD_REJECTED', 'AI modification chain discarded.', { projectId: activeProjectId });
    setPendingAiSuggestion(null);    
    setBaseForModalDiff(null);       
    setPreviousTreeStateForUndo(null); // The action was rejected, so clear the undo state.
    closeAiSuggestionModal();
  }, [projectManager, closeAiSuggestionModal, addHistoryEntry, setPendingAiSuggestion, setBaseForModalDiff, setPreviousTreeStateForUndo]);

  const handleUndoAiModification = useCallback(() => {
    if (!projectManager) {
      setError("Project system not fully initialized for undo.");
      return;
    }

    // If a modal is open, it means we are in a suggestion chain. "Undo" should cancel it.
    if (pendingAiSuggestion) {
        handleRejectAiSuggestion();
        return;
    }

    // If no modal is open, but there's an undo state, revert to it.
    if (previousTreeStateForUndoProp) { 
      setTechTreeData(previousTreeStateForUndoProp);
      addHistoryEntry('AI_MOD_UNDONE', 'Last AI modification undone.', { projectId: projectManager.activeProjectId });
      setPreviousTreeStateForUndo(null); 
      setModificationPrompt('');
      projectManager.handleSaveActiveProject(false); 
    } else {
      setError("No previous AI modification state available to undo.");
    }
  }, [
    pendingAiSuggestion, previousTreeStateForUndoProp, projectManager, handleRejectAiSuggestion,
    setError, setTechTreeData, setPreviousTreeStateForUndo, addHistoryEntry, setModificationPrompt
  ]);

  return {
    handleGenerateNewTree,
    handleApplyAiModification,
    handleConfirmAiSuggestion,
    handleRejectAiSuggestion,
    handleUndoAiModification,
  };
};