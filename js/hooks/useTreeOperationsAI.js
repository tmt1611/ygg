import { useCallback } from 'react';
import * as geminiService from '../services/geminiService.js';
import { getLockedNodeIds, countNodesInTree, compareAndAnnotateTree, findNodeById, updateNodeInTree, initializeNodes } from '../utils.js';

export const useTreeOperationsAI = ({
  apiKeyIsSet,
  modalManager,
  historyManager,
  projectManager,
  viewStates,
  setError,
  techTreeData,
  setTechTreeData,
  contextText,
  initialPrompt,
  previousTreeStateForUndoProp, 
  setPreviousTreeStateForUndo,
  baseForModalDiffProp, 
  setBaseForModalDiff,  
  setIsLoading,
  setIsModifying,
  setModificationPrompt,
  selectedGraphNodeId,
}) => {
  const { openAiSuggestionModal, closeAiSuggestionModal, openConfirmModal, setPendingAiSuggestion, pendingAiSuggestion } = modalManager;
  const { addHistoryEntry } = historyManager;

  const handleGenerateNewTree = useCallback(async () => {
    if (!projectManager || !viewStates) {
      setError("Project or view systems not fully initialized.");
      return;
    }
    const { activeProjectId, saveNewProject, handleSaveActiveProject } = projectManager;
    const { commonViewResetLogic, handleSwitchToFocusView } = viewStates;

    if (!initialPrompt.trim() || !apiKeyIsSet) {
      setError(!apiKeyIsSet ? "API Key not set. Cannot generate." : "Initial prompt (project context) cannot be empty.");
      return;
    }
    const performGeneration = async () => {
      commonViewResetLogic(true); 
      setIsLoading(true); setError(null);
      setPendingAiSuggestion(null); 
      setBaseForModalDiff(null);
      setPreviousTreeStateForUndo(null);
      try {
        const newTree = await geminiService.generateTechTree(initialPrompt);
        setTechTreeData(newTree);

        if (!activeProjectId) {
          const newProject = saveNewProject(newTree, initialPrompt);
          if (!newProject) { throw new Error("Failed to save new project after AI generation."); }
          addHistoryEntry('TREE_INIT_AI', `New project "${initialPrompt}" and tree generated by AI.`, { prompt: initialPrompt });
        } else {
          handleSaveActiveProject(false);
          addHistoryEntry('TREE_INIT_AI', `Tree regenerated for project "${contextText}" by AI.`, { prompt: initialPrompt });
        }
        // Switch to graph view to show the new structure
        if (viewStates) {
            viewStates.setYggdrasilViewMode('graph');
        }
      } catch (e) { setError(e); console.error("Gemini API Error (Generate):", e); } 
      finally { setIsLoading(false); }
    };

    if (techTreeData && (countNodesInTree(techTreeData) > 1 || (techTreeData.name !== 'New Project Root' && techTreeData.children && techTreeData.children.length > 0)) && projectManager.activeProjectId) {
      openConfirmModal({
        title: "Overwrite Current Tree?", message: `Generating a new tree for "${initialPrompt}" will replace the current structure in project "${contextText}". Are you sure?`,
        confirmText: "Overwrite", cancelText: "Cancel", onConfirm: performGeneration,
        confirmButtonStyle: 'danger'
      });
    } else { performGeneration(); }
  }, [
    initialPrompt, apiKeyIsSet, techTreeData, contextText, projectManager, viewStates, 
    setIsLoading, setError, setTechTreeData, setPreviousTreeStateForUndo, setBaseForModalDiff, setPendingAiSuggestion,
    openConfirmModal, addHistoryEntry
  ]);

  const handleApplyAiModification = useCallback(async (modificationPromptValue) => {
    if (!projectManager) {
        setError("Project system not fully initialized for AI modification.");
        return;
    }
    const { activeProjectId } = projectManager;

    if (!techTreeData && !pendingAiSuggestion) { 
        setError("No tree data loaded or pending suggestion to modify.");
        return;
    }
    if (!modificationPromptValue.trim() || !apiKeyIsSet) {
      setError(!apiKeyIsSet ? "API Key not set. Cannot modify." : "Modification prompt cannot be empty.");
      return;
    }

    setIsModifying(true); setError(null);

    let finalModificationPrompt = modificationPromptValue;
    if (selectedGraphNodeId && techTreeData) {
        const selectedNode = findNodeById(techTreeData, selectedGraphNodeId);
        if (selectedNode) {
            finalModificationPrompt = `The user has selected the node "${selectedNode.name}" (ID: ${selectedNode.id}). Apply the following instruction primarily to this node and its descendants, maintaining the integrity of the rest of the tree. Instruction: "${modificationPromptValue}"`;
        }
    }

    let currentModificationBase;
    if (pendingAiSuggestion) { 
        currentModificationBase = pendingAiSuggestion;
    } else { 
        currentModificationBase = techTreeData;
        if (techTreeData) { 
          setPreviousTreeStateForUndo(techTreeData); 
        }
    }
    
    if (!currentModificationBase) {
        setError("Base tree for modification is missing.");
        setIsModifying(false);
        return;
    }

    setBaseForModalDiff(currentModificationBase); 

    try {
      const lockedIds = getLockedNodeIds(currentModificationBase);
      const suggestedTree = await geminiService.modifyTechTreeByGemini(currentModificationBase, finalModificationPrompt, lockedIds);
      
      setPendingAiSuggestion(suggestedTree); 
      openAiSuggestionModal(suggestedTree); 
      addHistoryEntry('TREE_MOD_AI', 'AI proposed modifications.', { prompt: modificationPromptValue, projectId: activeProjectId });
    } catch (e) { 
      setError(e); 
      console.error("Gemini API Error (Modify):", e); 
    }
    finally { setIsModifying(false); }
  }, [
    techTreeData, apiKeyIsSet, projectManager, pendingAiSuggestion,
    openAiSuggestionModal, setPendingAiSuggestion, addHistoryEntry, 
    setError, setPreviousTreeStateForUndo, setIsModifying, setBaseForModalDiff,
    selectedGraphNodeId
  ]);

  const handleConfirmAiSuggestion = useCallback(() => {
    if (!projectManager) {
        setError("Project system not fully initialized to confirm AI suggestion.");
        return;
    }
    const { activeProjectId, handleSaveActiveProject } = projectManager;
    const suggestionToApply = pendingAiSuggestion; 
    if (suggestionToApply) {
      setPreviousTreeStateForUndo(techTreeData); // Save the state BEFORE applying the suggestion
      const annotatedTree = compareAndAnnotateTree(techTreeData, suggestionToApply);
      setTechTreeData(annotatedTree.annotatedTree);
      addHistoryEntry('AI_MOD_CONFIRMED', 'AI modifications applied to project.', { nodeCount: countNodesInTree(suggestionToApply), projectId: activeProjectId });
      setModificationPrompt(''); 
      handleSaveActiveProject(false);
      if (viewStates && viewStates.setSelectedGraphNodeId) {
        viewStates.setSelectedGraphNodeId(null);
      }
    }
    setPendingAiSuggestion(null); 
    setBaseForModalDiff(null);    
    // Do NOT clear the undo state, so the user can revert this confirmed change.
    closeAiSuggestionModal();
  }, [
    pendingAiSuggestion, projectManager, techTreeData,
    closeAiSuggestionModal, addHistoryEntry, 
    setTechTreeData, setModificationPrompt, setError,
    setPendingAiSuggestion, setBaseForModalDiff, setPreviousTreeStateForUndo,
    viewStates
  ]);

  const handleRejectAiSuggestion = useCallback(() => {
    if (!projectManager) {
        closeAiSuggestionModal();
        return;
    }
    const { activeProjectId } = projectManager;
    addHistoryEntry('AI_MOD_REJECTED', 'AI modification chain discarded.', { projectId: activeProjectId });
    setPendingAiSuggestion(null);    
    setBaseForModalDiff(null);       
    setPreviousTreeStateForUndo(null); 
    closeAiSuggestionModal();
  }, [projectManager, closeAiSuggestionModal, addHistoryEntry, setPendingAiSuggestion, setBaseForModalDiff, setPreviousTreeStateForUndo]);

  const handleUndoAiModification = useCallback(() => {
    if (!projectManager) {
      setError("Project system not fully initialized for undo.");
      return;
    }

    if (pendingAiSuggestion || baseForModalDiffProp) { 
      setTechTreeData(previousTreeStateForUndoProp || null); 
      addHistoryEntry('AI_MOD_UNDONE', 'AI modification chain cancelled and reverted.', { projectId: projectManager.activeProjectId });
      setPendingAiSuggestion(null);
      setBaseForModalDiff(null);
      setPreviousTreeStateForUndo(null);
      setModificationPrompt('');
    } else if (previousTreeStateForUndoProp) { 
      setTechTreeData(previousTreeStateForUndoProp);
      addHistoryEntry('AI_MOD_UNDONE', 'Last confirmed AI modification to project tree undone.', { projectId: projectManager.activeProjectId });
      setPreviousTreeStateForUndo(null); 
      setModificationPrompt('');
    } else {
      setError("No previous AI modification state available to undo.");
      return; 
    }
    projectManager.handleSaveActiveProject(false); 
  }, [
    pendingAiSuggestion, baseForModalDiffProp, previousTreeStateForUndoProp, projectManager, 
    setError, setTechTreeData, setPreviousTreeStateForUndo, setBaseForModalDiff, setPendingAiSuggestion, addHistoryEntry
  ]);

  return {
    handleGenerateNewTree,
    handleApplyAiModification,
    handleConfirmAiSuggestion,
    handleRejectAiSuggestion,
    handleUndoAiModification,
  };
};