
import { useCallback } from 'react';
// import { TechTreeNode } from '../types.js'; // Types removed
import * as geminiService from '../services/geminiService.js';
import { getLockedNodeIds, countNodesInTree } from '../utils.js';
// import { UseModalManagerReturn } from './useModalManager.js'; // Types removed
// import { UseHistoryManagerReturn } from './useHistoryManager.js'; // Types removed
// import { UseProjectManagementReturn } from './useProjectManagement.js'; // Types removed
// import { UseViewStatesReturn } from './useViewStates.js'; // Types removed

export const useTreeOperationsAI = ({
  apiKeyIsSet,
  modalManager,
  historyManager,
  projectManager,
  viewStates,
  setError,
  techTreeData,
  setTechTreeData,
  contextText,
  initialPrompt,
  previousTreeStateForUndoProp, 
  setPreviousTreeStateForUndo,
  baseForModalDiffProp, 
  setBaseForModalDiff,  
  setIsLoading,
  setIsModifying,
  setModificationPromptFromHook,
}) => {
  const { openAiSuggestionModal, closeAiSuggestionModal, openConfirmModal, setPendingAiSuggestion, pendingAiSuggestion } = modalManager;
  const { addHistoryEntry } = historyManager;

  const handleGenerateNewTree = useCallback(async () => {
    if (!projectManager || !viewStates) {
      setError("Project or view systems not fully initialized.");
      return;
    }
    const { activeProjectId, saveCurrentTreeAsProject, handleSaveActiveProject } = projectManager;
    const { commonViewResetLogic, handleSwitchToFocusView } = viewStates;

    if (!initialPrompt.trim() || !apiKeyIsSet) {
      setError(!apiKeyIsSet ? "API Key not set. Cannot generate." : "Initial prompt (project context) cannot be empty.");
      return;
    }
    const performGeneration = async () => {
      commonViewResetLogic(true); 
      setIsLoading(true); setError(null);
      setPendingAiSuggestion(null); 
      setBaseForModalDiff(null);
      setPreviousTreeStateForUndo(null);
      try {
        const newTree = await geminiService.generateTechTree(initialPrompt);
        setTechTreeData(newTree);

        if (!activeProjectId) {
          const newProject = saveCurrentTreeAsProject(initialPrompt);
          if (!newProject) { throw new Error("Failed to save new project after AI generation."); }
          addHistoryEntry('TREE_INIT_AI', `New project "${initialPrompt}" and tree generated by AI.`, { prompt: initialPrompt });
        } else {
          handleSaveActiveProject(false);
          addHistoryEntry('TREE_INIT_AI', `Tree regenerated for project "${contextText}" by AI.`, { prompt: initialPrompt });
        }
        if (newTree.id) {
          handleSwitchToFocusView(newTree.id);
        }
      } catch (e) { setError(e.message || "An unknown error occurred during AI generation."); console.error("Gemini API Error (Generate):", e); } 
      finally { setIsLoading(false); }
    };

    if (techTreeData && (countNodesInTree(techTreeData) > 1 || (techTreeData.name !== 'New Project Root' && techTreeData.children && techTreeData.children.length > 0)) && projectManager.activeProjectId) {
      openConfirmModal({
        title: "Overwrite Current Tree?", message: `Generating a new tree for "${initialPrompt}" will replace the current structure in project "${contextText}". Are you sure?`,
        confirmText: "Overwrite", cancelText: "Cancel", onConfirm: performGeneration,
        confirmButtonStyle: { backgroundColor: 'var(--error-color)', borderColor: 'var(--error-color)' }
      });
    } else { performGeneration(); }
  }, [
    initialPrompt, apiKeyIsSet, techTreeData, contextText, projectManager, viewStates, 
    setIsLoading, setError, setTechTreeData, setPreviousTreeStateForUndo, setBaseForModalDiff, setPendingAiSuggestion,
    openConfirmModal, addHistoryEntry
  ]);

  const handleApplyAiModification = useCallback(async (modificationPromptValue) => {
    if (!projectManager) {
        setError("Project system not fully initialized for AI modification.");
        return;
    }
    const { activeProjectId } = projectManager;

    if (!techTreeData && !pendingAiSuggestion) { 
        setError("No tree data loaded or pending suggestion to modify.");
        return;
    }
    if (!modificationPromptValue.trim() || !apiKeyIsSet) {
      setError(!apiKeyIsSet ? "API Key not set. Cannot modify." : "Modification prompt cannot be empty.");
      return;
    }

    setIsModifying(true); setError(null);

    let currentModificationBase;
    if (pendingAiSuggestion) { 
        currentModificationBase = pendingAiSuggestion;
    } else { 
        currentModificationBase = techTreeData;
        if (techTreeData) { 
          setPreviousTreeStateForUndo(techTreeData); 
        }
    }
    
    if (!currentModificationBase) {
        setError("Base tree for modification is missing.");
        setIsModifying(false);
        return;
    }

    setBaseForModalDiff(currentModificationBase); 

    try {
      const lockedIds = getLockedNodeIds(currentModificationBase);
      const suggestedTree = await geminiService.modifyTechTreeByGemini(currentModificationBase, modificationPromptValue, lockedIds);
      
      setPendingAiSuggestion(suggestedTree); 
      openAiSuggestionModal(suggestedTree); 
      addHistoryEntry('TREE_MOD_AI', 'AI proposed modifications.', { prompt: modificationPromptValue, projectId: activeProjectId });
    } catch (e) { 
      setError(e.message || "An unknown error occurred during AI modification."); 
      console.error("Gemini API Error (Modify):", e); 
    }
    finally { setIsModifying(false); }
  }, [
    techTreeData, apiKeyIsSet, projectManager, pendingAiSuggestion,
    openAiSuggestionModal, setPendingAiSuggestion, addHistoryEntry, 
    setError, setPreviousTreeStateForUndo, setIsModifying, setBaseForModalDiff
  ]);

  const handleConfirmAiSuggestion = useCallback(() => {
    if (!projectManager) {
        setError("Project system not fully initialized to confirm AI suggestion.");
        return;
    }
    const { activeProjectId, handleSaveActiveProject } = projectManager;
    const suggestionToApply = pendingAiSuggestion; 
    if (suggestionToApply) {
      setTechTreeData(suggestionToApply);
      addHistoryEntry('AI_MOD_CONFIRMED', 'AI modifications applied to project.', { nodeCount: countNodesInTree(suggestionToApply), projectId: activeProjectId });
      setModificationPromptFromHook(''); 
      handleSaveActiveProject(false);
    }
    setPendingAiSuggestion(null); 
    setBaseForModalDiff(null);    
    setPreviousTreeStateForUndo(null); 
    closeAiSuggestionModal();
  }, [
    pendingAiSuggestion, projectManager,
    closeAiSuggestionModal, addHistoryEntry, 
    setTechTreeData, setModificationPromptFromHook, setError,
    setPendingAiSuggestion, setBaseForModalDiff, setPreviousTreeStateForUndo
  ]);

  const handleRejectAiSuggestion = useCallback(() => {
    if (!projectManager) {
        closeAiSuggestionModal();
        return;
    }
    const { activeProjectId } = projectManager;
    addHistoryEntry('AI_MOD_REJECTED', 'AI modification chain discarded.', { projectId: activeProjectId });
    setPendingAiSuggestion(null);    
    setBaseForModalDiff(null);       
    setPreviousTreeStateForUndo(null); 
    closeAiSuggestionModal();
  }, [projectManager, closeAiSuggestionModal, addHistoryEntry, setPendingAiSuggestion, setBaseForModalDiff, setPreviousTreeStateForUndo]);

  const handleUndoAiModification = useCallback(() => {
    if (!projectManager) {
      setError("Project system not fully initialized for undo.");
      return;
    }

    if (pendingAiSuggestion || baseForModalDiffProp) { 
      setTechTreeData(previousTreeStateForUndoProp || null); 
      addHistoryEntry('AI_MOD_UNDONE', 'AI modification chain cancelled and reverted.', { projectId: projectManager.activeProjectId });
      setPendingAiSuggestion(null);
      setBaseForModalDiff(null);
      setPreviousTreeStateForUndo(null);
    } else if (previousTreeStateForUndoProp) { 
      setTechTreeData(previousTreeStateForUndoProp);
      addHistoryEntry('AI_MOD_UNDONE', 'Last confirmed AI modification to project tree undone.', { projectId: projectManager.activeProjectId });
      setPreviousTreeStateForUndo(null); 
    } else {
      setError("No previous AI modification state available to undo.");
      return; 
    }
    projectManager.handleSaveActiveProject(false); 
  }, [
    pendingAiSuggestion, baseForModalDiffProp, previousTreeStateForUndoProp, projectManager, 
    setError, setTechTreeData, setPreviousTreeStateForUndo, setBaseForModalDiff, setPendingAiSuggestion, addHistoryEntry
  ]);

  return {
    handleGenerateNewTree,
    handleApplyAiModification,
    handleConfirmAiSuggestion,
    handleRejectAiSuggestion,
    handleUndoAiModification,
  };
};
